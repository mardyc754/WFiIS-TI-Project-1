<!DOCTYPE html>
<html lang="pl-PL">
    <head>
        <link rel=stylesheet href="style.css">
        <link rel="icon" href="favicon.ico">
        <script src="main.js"></script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta charset="UTF-8" />
        <title>Projekt 1</title>
    </head>
    <body>
        <header>
            <h1>Drzewo poszukiwań binarnych</h1>
        </header>
        <div class="flex">
        <nav>
            <ul>
                <li><button class="link" onclick="changeContent(event, 'definition')" id="defaultOpen">Definicja</button></li>
                <li><button class="link" onclick="changeContent(event, 'tree-walk')">Przeszukiwanie BST</button></li>
                <li><button class="link" onclick="changeContent(event, 'nodes')">Dodawanie i usuwanie węzłów</button></li>
                <li><button class="link" onclick="changeContent(event, 'node-properties')">Własności węzłów</button></li>
                <li><button class="link" onclick="changeContent(event, 'simulation')">Symulacja</button></li>
                <li><button class="link" onclick="changeContent(event, 'other')">Więcej informacji</button></li>
                <li><button class="link" onclick="changeContent(event, 'about')">O projekcie</button></li>
            </ul>
        </nav>
        <div class="main-content">
            <article id="definition">
                <h2>Definicja</h2>
                <p>Drzewo poszukiwań binarnych (ang. Binary Search Tree, w skrócie BST) jest jednym z rodzajów drzewa binarnego, czyli takiego, w którym każdy z węzłów może posiadać
                    maksymalnie dwóch bezpośrednich potomków.
                    Swoją nazwę zawdzięcza swojej właściwości umożliwiającej wyszukiwanie binarne. Węzły w drzewie BST 
                    uporządkowane są w ścisłej hierarchii:</p>
                    <ul>
                    <li>lewy potomek węzła ma wartość <strong>nie większą</strong> od wartości rodzica,</li> 
                    <li>prawy potomek węzła ma zawsze <strong>większą</strong> wartość od wartości rodzica.</li>
                </ul>
                <p>Prawie każdy z węzłów w drzewie binarnym posiada węzeł nadrzędny, zwany <strong>rodzicem</strong>. Wyjątkiem jest węzeł główny drzewa binarnego, zwany <strong>korzeniem</strong>.</p>
                <p>Jeżeli dany węzeł nie posiada lewego i/lub prawego potomka, to za wartość potomka przyjmuje się <strong>NULL</strong>, czyli brak wartości.</p>
                <p>Własności drzewa BST sprawiają, że może być ono wykorzystane jako słownik lub kolejka priorytetowa.</p>        
            </article>
            <article id="node-properties">
                <h2>Własności węzłów</h2>
                
                <p>Drzewo poszukiwań binarnych ma przyjemną własność, że <strong>najmniejszym</strong> jego elementem jest węzeł znajdujący się <strong>najdalej na lewo</strong> od korzenia:</p>
                <pre>
                    TREE-MINIMUM(x)
                    1.   while left[x] != NULL
                    2.       do x = left[x]
                    3.   return x 
                </pre>
                <p>natomiast <strong>największym</strong> elementem w drzewie jest - analogicznie - węzeł znajdujący się <strong>najdalej na prawo</strong> od korzenia:</p>
                <pre>
                    TREE-MAXIMUM(x)
                    1.   while right[x] != NULL
                    2.       do x = right[x]
                    3.   return x 
                 </pre>
                
                <p>Węzły mogą także posiadać swojego następnika lub poprzednika. <strong>Następnik</strong> w drzewie BST to element o <strong>najmniejszej wartości większej od wartości klucza</strong> węzła.
                    Dlatego też można go odnaleźć za pomocą poniższego algorytmu:</p>
                <pre>
                    TREE-SUCCESSOR(x)
                    1.  if right[x] != NULL
                    2.      then return TREE-MINIMUM(right[x])
                    3.  y = parent[x]
                    4.  while y != NULL and x == right[y] 
                    5.      do x = y
                    6.      y = parent[y]
                    7.  return y
                </pre>
                <p>Analogicznie można wyznaczyć <strong>poprzednika</strong> danego węzła - jest to po prostu <strong>największy element, który jest mniejszy</strong> od danego węzła:</p>
                <pre>
                    TREE-PREDECESSOR(x)
                    1.  if left[x] != NULL
                    2.      then return TREE-MAXIMUM(left[x])
                    3.  y = parent[x]
                    4.  while y != NULL and x == left[y] 
                    5.      do x = y
                    6.      y = parent[y]
                    7.  return y
                </pre>
            </article>
            <article id="tree-walk">
                <h2>Przeszukiwanie BST</h2>
                <p>Własność drzewa BST umożliwia wypisanie wszystkich jego węzłów na 3 sposoby: metodą inorder, preorder lub postorder.</p>
                <ul>
                    <li><strong>Metoda inorder</strong> pozwala na wypisanie elementów w drzewie binarnym od węzła najdalej na lewo od węzła najdalej na prawo od korzenia.
                        Po węzłach przechodzi zgodnie ze schematem: lewy potomek, węzeł, prawy potomek, rodzic. W ten sposób dla drzewa BST można uzyskać posortowany ciąg elementów:
                        <pre>
                            INORDER-TRAVERSAL(x)
                            1.  if x != NULL then
                            2.      INORDER-TRAVERSAL(left[x])
                            3.      print(key[x])
                            4.      INORDER-TRAVERSAL(right[x])
                        </pre>
                    </li>
                    <li><strong>Metoda preorder</strong> pozwala na wypisanie elementów w drzewie BST od korzenia, poprzez lewych sąsiadów węzłów, do prawych sąsiadów:
                        <pre>
                            PREORDER-TRAVERSAL(x)
                            1.  if x != NULL then
                            2.      print(key[x])
                            3.      then PREORDER-TRAVERSAL(left[x])
                            4.      PREORDER-TRAVERSAL(right[x])
                        </pre>
                    </li>
                    <li><strong>Metoda postorder</strong> pozwala na wypisanie elementów w drzewie BST w kolejności od lewej do prawej 
                        dla danej wysokości drzewa startując najwyżej i zmierzając do korzenia:
                        <pre>
                            POSTORDER-TRAVERSAL(x)
                            1.  if x != NULL then
                            2.      POSTORDER-TRAVERSAL(left[x])
                            3.      POSTRDER-TRAVERSAL(right[x])
                            4.      print(key[x])
                        </pre>
                    </li>
                </ul>
                <p>Średnia złożoność czasowa operacji przechodzenia po drzewie binarnym wynosi <i>O(n)</i>.</p>
            </article>
            <article id="nodes">
                <h2>Dodawanie i usuwanie węzłów</h2>
                <p>Dodawanie węzła do drzewa BST wykonywane jest zgodnie z poniższą procedurą. Do procedury tej przekazywany jest węzeł z, posiadający jako klucz key[z]:
                    <pre>
                        TREE-INSERT(T, z)
                        1.  y = NULL
                        2.  x = root[T]
                        3.  while x != NULL
                        4.      do y = x
                        5.      if key[z] &lt; key[x]
                        6.          then x = left[x]
                        7.          else x = right[x]
                        8.  parent[z] = y
                        9.  if y == NULL
                        10.     then root[T] = z
                        11.     else if key[z] &lt; key[y]
                        12.         then left[y] = z
                        13.         else right[y] = z
                    </pre>
                </p>
                <p>Trudniejszą operacją jest usunięcie węzła, ponieważ operacja ta często wiąże się z restrukturyzacją położenia węzłów.
                    W zależności od posiadanych potomków węzła z rozważamy 3 przypadki:</p>
                    <ul>
                        <li>Jeżeli węzeł z nie posiada potomków, to w rodzicu zastępujemy wskaźnik do z wartością NULL</li>
                        <li>Jeżeli węzeł z posiada jednego potomka, to zastępujemy węzeł z węzłem jego potomka</li>
                        <li>Jeżeli węzeł z posiada obydwu potomków, to zastępujemy węzeł z następnikiem nie posiadającym lewego potomka</li>
                    </ul>
                <p>Całość tą można zaimplementować jak w poniższym algorytmie, gdzie węzeł y może reprezentować węzeł z lub jego następnika, 
                    kiedy węzeł z ma obydwu potomków:</p>
                    <pre>
                        TREE-DELETE(T, z)
                        1.  if left[z] == NULL or right[z] == NULL
                        2.      then y = z
                        3.      else y = TREE-SUCCESOR(z)
                        4.  if left[y] != NULL
                        5.      then x = left[y]
                        6.      else x = right[y]
                        7.  if x != NULL
                        8.      then parent[x] = parent[y]
                        9.  if parent[y] == NULL
                        10.     then root[T] = x
                        11.     else if y == left[parent[y]]
                        12.         then left[parent[y]] = x
                    </pre>
            </article>
            <article id="simulation">
                <h2>Symulacja</h2>
                <p>W poniższej symulacji możesz sam utworzyć własne drzewo binarne lub wygenerować je losowo.</p>
            </article>
            <article id="other">
                <h2>Więcej informacji</h2>
                <p>Więcej o drzewach binarnych możesz dowiedzieć się z poniższego filmu:</p>
            </article>
            <article id="about">
                <h2>O projekcie</h2>
                <p>Projekt ten został zrealizowany w celu zadania na przedmiot "Techniki internetowe", 5 semestr. Celem tego projektu
                    było wykorzystanie HTML, CSS i JavaScript do przedstawienia wybranego pojęcia z matematyki, fizyki lub informatyki.
                    Działanie projektu przetestowano na przeglądarkach Google Chrome oraz Firefox.
                </p>
            </article>
        </div>
        </div>
        <footer>
            <p>&copy; 2021 Marta Dychała</p>
        </footer>
    </body>
</html>